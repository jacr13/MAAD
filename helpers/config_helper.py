import os
import os.path as osp


class Config:
    """Class that allows args to be used as a dictionary or namespace.

    Example:
    ```
    args = parser.parse_args()
    config = Config(args)
    print(config.learning_rate)
    config.learning_rate = 0.5  # change the value of learning_rate in config
    # or equivalent
    print(config['learning_rate'])
    config['learning_rate'] = 0.5
    # or use get
    print(config.get('learning_rate', 0.5))

    ```
    """

    def __init__(self, args, filename="hyperparameters", path=None):
        self.__dict__.update(vars(args))
        self.__filename = filename
        self.__path = path
        # need to handle adding new attribute to special folder

    def __setitem__(self, key, item):
        self.__dict__[key] = item

    def __getitem__(self, key):
        return self.__dict__[key]

    def __repr__(self):
        return repr(self.__dict__)

    def __len__(self):
        return len(self.__dict__)

    def __delitem__(self, key):
        del self.__dict__[key]

    def clear(self):
        return self.__dict__.clear()

    def copy(self):
        return self.__dict__.copy()

    def get(self, *args, **kwargs):
        return self.__dict__.get(*args, **kwargs)

    def has_key(self, k):
        return k in self.__dict__

    def update(self, *args, defaults=None, change_uuid=True, **kwargs):
        if defaults is None:
            return self.__dict__.update(*args, **kwargs)

        assert len(args) == 1, "You should provide only one argument without key"
        config = args[0]
        for k, v in self.__dict__.items():
            # if key is class specific attribute, continue
            if k.startswith(f"_{self.__class__.__name__}__"):
                continue

            # if key not in defaults or config, continue
            if k not in defaults or k not in config:
                continue

            # if value was not changed, update it with new config value
            if v == defaults[k]:
                self.__dict__[k] = config[k]

            # change values generated by code
            if k in ["uuid"] and change_uuid:
                self.__dict__[k] = config[k]

    def keys(self):
        return self.__dict__.keys()

    def values(self):
        return self.__dict__.values()

    def items(self):
        return self.__dict__.items()

    def pop(self, *args):
        return self.__dict__.pop(*args)

    def __cmp__(self, dict_):
        return self.__cmp__(self.__dict__, dict_)

    def __contains__(self, item):
        return item in self.__dict__

    def __iter__(self):
        return iter(self.__dict__)

    def to_dict(self):
        """Return a dict with config."""
        # remove class specific attributes from the dictionary
        config = {
            k: v
            for k, v in self.__dict__.items()
            if not k.startswith(f"_{self.__class__.__name__}__")
        }
        return config

    def save(self, file_type="yaml", path=None):
        """Saves parameters to a file of a given type (yaml or json)"""
        if path is not None:
            self.__path = path

        os.makedirs(self.__path, exist_ok=True)
        config = self.to_dict()
        if file_type == "yaml":
            import yaml

            with open(osp.join(self.__path, f"{self.__filename}.yaml"), "w") as outfile:
                yaml.safe_dump(config, outfile, default_flow_style=False)
        elif file_type == " json":
            import json

            with open(osp.join(config, f"{self.__filename}.json"), "w") as outfile:
                json.dump(self.__dict__, outfile, indent=4)
        else:
            ValueError(f"Unknown file type {file_type}")
